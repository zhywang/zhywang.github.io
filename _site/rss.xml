<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0">
<channel>
        <title>zhywang's blog</title>
        <description>zhywang's blog - zhywang</description>
        <link>http://zhywang.github.io</link>
        <link>http://zhywang.github.io</link>
        <lastBuildDate>2013-08-25T11:41:42+08:00</lastBuildDate>
        <pubDate>2013-08-25T11:41:42+08:00</pubDate>
        <ttl>1800</ttl>


        <item>
                <title>关于命令式编程、面向对象编程与函数式编程的思考</title>
                <description>&lt;p&gt;继命令式编程与面向对象编程之后，函数式编程成为近来比较热门的编程范式之一，那么，命令式编程、面向对象编程与日渐流行的函数式编程，三种编程范式背后的思想有什么区别？本文就是我对这个问题的一些思考，分享出来，与大家探讨。&lt;/p&gt;

&lt;p&gt;在下文中，我会通过实现一个简单的数据结构－－栈（Stack），来演示不同编程范式在解决具体问题时的实践。&lt;/p&gt;

&lt;p&gt;为了简化起见，本文中实现的Stack只需要提供以下3个函数：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;is_empty： 返回一个标志，表示当前栈是否为空&lt;/li&gt;

&lt;li&gt;pop： 从栈顶弹出一个元素，若栈为空，则出错&lt;/li&gt;

&lt;li&gt;push： 将一个元素压入栈&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;pop和push这两个函数至少应该支持int型数据的出入栈。&lt;/p&gt;

&lt;h3 id='id1'&gt;语言选择&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;命令式编程：经典的C语言&lt;/li&gt;

&lt;li&gt;面向对象编程：流行的Java语言&lt;/li&gt;

&lt;li&gt;函数式编程：近年来新兴的基于JVM平台的Scala语言&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id='id2'&gt;不同编程范式中的实现&lt;/h3&gt;

&lt;h4 id='id3'&gt;命令式&lt;/h4&gt;

&lt;p&gt;作为命令式编程语言代表的C语言，具有语法简洁，功能强大，支持结构化编程的特点，也是各计算机专业的必修课。&lt;/p&gt;

&lt;p&gt;在C语言中实现Stack，简单的解决方案是使用数组存储数据，代码如下：&lt;/p&gt;

&lt;h6 id='c__cat_stackh'&gt;~/c $ cat stack.h&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;#ifndef _STACK_H
#define _STACK_H

typedef struct stack{
	int *data;
	int capacity;
	int index;
} *Stack;

Stack create();
int is_empty(Stack);
int pop(int*, Stack);
int push(int, Stack);

#endif&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id='c__cat_stackc'&gt;~/c $ cat stack.c&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;quot;stack.h&amp;quot;
#include &amp;lt;stdlib.h&amp;gt;

#define INCREASE_SIZE 8
int ensureCapacity(Stack stack) {
    if(stack-&amp;gt;index + 1 &amp;lt; stack-&amp;gt;capacity)
        return 1;
	int* temp= (int*)realloc(stack-&amp;gt;data, sizeof(int)*(stack-&amp;gt;capacity + INCREASE_SIZE));
    if(temp == NULL){
        return 0;
    }
	stack-&amp;gt;data=temp;
	stack-&amp;gt;capacity+=INCREASE_SIZE;
    return 1;
}

Stack create() {
	Stack stack=(Stack)malloc(sizeof(struct stack));
	if(stack) {
		stack-&amp;gt;data=NULL;
		stack-&amp;gt;index=-1;
		stack-&amp;gt;capacity=0;
	}
	return stack;
}

int is_empty(Stack stack) {
    return stack-&amp;gt;index == -1;
}

int pop(int *elem, Stack stack) {
	if(is_empty(stack))
        return 0;
	*elem = stack-&amp;gt;data[stack-&amp;gt;index];
	stack-&amp;gt;index--;
	return 1;
}

int push(int value, Stack stack) {
	if(!ensureCapacity(stack))
		return 0;
	stack-&amp;gt;data[++(stack-&amp;gt;index)]=value;
	return 1;
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以这样使用上面定义的栈：&lt;/p&gt;

&lt;h6 id='c__cat_mainc'&gt;~/c $ cat main.c&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;quot;stack.h&amp;quot;
int main(int argc, char* argv[]) {
	int i=0;
	Stack s=create();
	while(i&amp;lt;10 &amp;amp;&amp;amp; push(i, s))
		i++;
	while(!is_empty(s) &amp;amp;&amp;amp; pop(&amp;amp;i, s))
		printf(&amp;quot;%d\n&amp;quot;,i);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这段代码非常简单，但是通过这段代码我们仍然不难发现C语言的不便之处：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不支持数据与操作绑定：由于难以实现面向对象类编程语言中的this关键字的功能，导致数据和操作分离。&lt;/li&gt;

&lt;li&gt;模块化的支持差：在stack.h文件中，声明接口函数的同时，也定义了具体实现使用的数据结构，造成声明和实现的紧耦合，如果修改实现（比如使用链表代替数组），则作为接口的stack.h文件也要同时修改。&lt;/li&gt;

&lt;li&gt;不支持数据隔离：对于任意代码，Stack中的数据都是可见的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;下面我们看一下面向对象编程语言中的做法。&lt;/p&gt;

&lt;h4 id='id4'&gt;面向对象式&lt;/h4&gt;

&lt;p&gt;Java语言是目前最流行的面向对象式编程语言，相比C++，Java的语法更加简单，而且支持自动内存管理，提高开发效率。&lt;/p&gt;

&lt;p&gt;使用Java实现Stack时，我们仍然可以在底层使用数组来保存数据，代码如下：&lt;/p&gt;

&lt;h6 id='java__cat_stackjava'&gt;~/java $ cat Stack.java&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;public interface Stack&amp;lt;T&amp;gt; {
    boolean isEmpty();
    T pop();
    void push(T value);
}&lt;/code&gt;&lt;/pre&gt;

&lt;h6 id='java__cat_arraystackjava'&gt;~/java $ cat ArrayStack.java&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;import java.util.Arrays;

public class ArrayStack&amp;lt;T&amp;gt; implements Stack&amp;lt;T&amp;gt; {
    private static final int INCREASE_SIZE = 8;
    private Object[] data;
    private int index;

    public ArrayStack() {
        data = new Object[0];
        index = -1;
    }

    @Override
    public boolean isEmpty() {
        return index == -1;
    }

    @Override
    @SuppressWarnings(&amp;quot;unchecked&amp;quot;)
    public T pop() {
        return (T) data[index--];
    }

    @Override
    public void push(T value) {
        ensureCapacity();
        data[++index] = value;
    }

    private void ensureCapacity() {
        if (index == data.length - 1) {
            data = Arrays.copyOf(data, data.length + INCREASE_SIZE);
        }
    }

}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们可以这样使用以上定义的Stack：&lt;/p&gt;

&lt;h6 id='java__cat_mainjava'&gt;~/java $ cat Main.java&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;public class Main {
    public static void main(String[] args) {
        Stack&amp;lt;Integer&amp;gt; stack = new ArrayStack&amp;lt;Integer&amp;gt;();
        for (int i = 0; i &amp;lt; 10; i++)
            stack.push(i);
        while (!stack.isEmpty())
            System.out.println(stack.pop());
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这段代码中，利用面向对象编程语言的封装、继承及多态的特性，解决了上一节的几个问题：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;#160;数据与操作封装成类，使用时更加自然直观。&lt;/li&gt;

&lt;li&gt;&amp;#160;接口Stack只声明操作，不需要定义具体实现，不同的实现可以有不同的内部数据结构。&lt;/li&gt;

&lt;li&gt;&amp;#160;实现了数据隔离，无法从外部访问具体实现内部的数据结构。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id='id5'&gt;换一种思考方式&lt;/h4&gt;

&lt;p&gt;对于示例，我们可以用另外一种思路来实现需求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;is_empty： 只有当Stack为空时，才会返回true，否则为false。&lt;/li&gt;

&lt;li&gt;pop： 将原来的Stack拆成两部分，第一部分是栈顶的元素，第二部分是除去第一部分之后的Stack，返回第一部分。&lt;/li&gt;

&lt;li&gt;push： 使用新的元素和原来的Stack，拼成一个新Stack，这个Stack由两部分组成，第一部分是新元素，第二部分是原来的栈。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在这种实现中，pop后原来的栈内容不会改变，为了解决这个问题，我们可以增加一个方法，并修改pop的行为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;top： 返回栈顶元素。&lt;/li&gt;

&lt;li&gt;pop： 将原来的Stack拆成两部分，第一部分是栈顶的元素，第二部分是除去第一部分之后的Stack，返回第二部分。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码如下：&lt;/p&gt;

&lt;p&gt;首先仍然是定义接口：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public abstract class Stack&amp;lt;T&amp;gt; {
    public abstract boolean isEmpty();

    public abstract T top();

    public abstract Stack&amp;lt;T&amp;gt; pop();

    public abstract Stack&amp;lt;T&amp;gt; push(T value);
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后是实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class EmpytStack&amp;lt;T&amp;gt; extends Stack&amp;lt;T&amp;gt; {
    @Override
    public boolean isEmpty() {
        return true;
    }

    @Override
    public T top() {
        throw new IllegalArgumentException(&amp;quot;Empyt stack has no top elem!&amp;quot;);
    }

    @Override
    public Stack&amp;lt;T&amp;gt; pop() {
        throw new IllegalArgumentException(&amp;quot;Empyt stack can not pop!&amp;quot;);
    }

    @Override
    public Stack&amp;lt;T&amp;gt; push(T value) {
        return new NonEmptyStack&amp;lt;T&amp;gt;(value, this);
    }

}

class NonEmptyStack&amp;lt;T&amp;gt; extends Stack&amp;lt;T&amp;gt; {
    private final T value;
    private final Stack&amp;lt;T&amp;gt; oldStack;

    NonEmptyStack(T value, Stack&amp;lt;T&amp;gt; oldStack) {
        this.value = value;
        this.oldStack = oldStack;
    }

    @Override
    public boolean isEmpty() {
        return false;
    }

    @Override
    public T top() {
        return value;
    }

    @Override
    public Stack&amp;lt;T&amp;gt; pop() {
        return oldStack;
    }

    @Override
    public Stack&amp;lt;T&amp;gt; push(T value) {
        return new NonEmptyStack&amp;lt;T&amp;gt;(value, this);
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class Main {
    public static &amp;lt;T&amp;gt; Stack&amp;lt;T&amp;gt; createStack(T... values) {
        return createStack(values, 0, new EmpytStack&amp;lt;T&amp;gt;());
    }

    public static &amp;lt;T&amp;gt; Stack&amp;lt;T&amp;gt; createStack(T[] values, int current, Stack&amp;lt;T&amp;gt; stack) {
        if (current == values.length)
            return stack;
        Stack&amp;lt;T&amp;gt; newStack = stack.push(values[current]);
        current += 1;
        return createStack(values, current, newStack);
    }
    private static &amp;lt;T&amp;gt; void printStack(Stack&amp;lt;T&amp;gt; stack) {
        if (stack.isEmpty()) 
            return;
        else {
            System.out.println(stack.top());
            printStack(stack.pop());
        }
    }
    public static void main(String[] args) {
        printStack(createStack(0, 1, 2, 3, 4, 5));
    }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;相比上面的实现，使用这种方式的代码更加容易理解，并且有下面两个特点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;内部状态不可改变：Stack的属性全部是final的，每次压栈都会创建新的Stack，在Java中导致程序运行时创建大量对象。&lt;/li&gt;

&lt;li&gt;使用递归而不是循环：初始化和遍历栈时，都使用递归而不是循环，由于Java缺少对于递归的优化，运行时资源消耗会增加。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这两个特点也是函数式编程的特点，&lt;/p&gt;

&lt;p&gt;下面，我们看一下在原生支持函数式编程的Scala中，我们可以怎么做。&lt;/p&gt;

&lt;h4 id='id6'&gt;函数式&lt;/h4&gt;

&lt;p&gt;由于项目的需要，最近我在学习使用Scala语言，相比Java语言，Scala语言原生支持函数式编程，并且基于JVM，对于有Java语言经验的程序员来说比较容易学习。下面是我沿用上一小节的思路，使用Scala语言实现的Stack：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;trait Stack[+A] {
  def push[B &amp;gt;: A](elem: B): Stack[B]

  def pop(): Stack[A]

  def top(): A

  def isEmpty(): Boolean
}


object EmptyStack extends Stack[Nothing] {
  def push[A](elem: A): Stack[A] = NonEmptyStack[A](elem, this)

  def isEmpty(): Boolean = true

  def pop(): Nothing = sys.error(&amp;quot;Empty stack can not pop!&amp;quot;)

  def top(): Nothing = sys.error(&amp;quot;Empty stack can not top!&amp;quot;)
}

case class NonEmptyStack[A](elem: A, tail: Stack[A]) extends Stack[A] {
  def push[B &amp;gt;: A](elem: B): Stack[B] = NonEmptyStack(elem, this)

  def pop(): Stack[A] = tail

  def top(): A = elem

  def isEmpty(): Boolean = false
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;object Main {
  def createStack(values: Any*): Stack[Any] = {
    values match {
      case Nil =&amp;gt; EmptyStack
      case _ =&amp;gt; values.tail./:(EmptyStack.push(values.head))(_.push(_))
    }
  }

  def printStack[A](s: Stack[A]): Unit = {
    s match {
      case EmptyStack =&amp;gt; println
      case stack =&amp;gt; {
        println(s.top())
        printStack(s.pop())
      }
    }
  }

  def main(args: Array[String]): Unit = {
    printStack(createStack(1, 2l, 3.0f, 4.0, &amp;quot;test&amp;quot;, null))
  }
}&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码相比上一节中的Java实现的特点：&lt;/p&gt;

&lt;p&gt;* 语法更加简洁。&lt;/p&gt;

&lt;p&gt;* 提供更多的函数支持遍历和递归。&lt;/p&gt;</description>
                <link>http://zhywang.github.io/scala/comparison-of-programming-paradigms</link>
                <guid>http://zhywang.github.io/scala/comparison-of-programming-paradigms</guid>
                <pubDate>2013-08-24T00:00:00+08:00</pubDate>
        </item>


</channel>
</rss>
